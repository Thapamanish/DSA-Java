= Queue & Deque (ArrayDeque, LinkedList, PriorityQueue) – Quick Reference
:toc: macro
:toclevels: 2
:source-highlighter: highlightjs

[.lead]
Cheatsheet covering the **common API** for `Queue` / `Deque`, plus specifics for **ArrayDeque**, **LinkedList (as Deque)**, and **PriorityQueue**. Also includes complexity, gotchas, and DSA patterns (BFS, sliding window, monotonic queue, etc.).

toc::[]

== Core Interfaces
* `Queue<E>` – FIFO; key ops: `offer`, `poll`, `peek` (and stricter `add`, `remove`, `element`).
* `Deque<E>` – double-ended queue; supports both **queue** and **stack** semantics via ends.

== Common Queue Operations
(Java provides both **total-failure** and **exception-throwing** variants.)

[cols="30,35,35", options="header"]
|===
| Operation | Preferred (no exceptions) | Throws on failure
| Insert | `offer(e)` | `add(e)`
| Remove head | `poll()` | `remove()`
| Peek head | `peek()` | `element()`
|===

Example:
[source,java]
----
Queue<Integer> q = new ArrayDeque<>();
q.offer(10); q.offer(20); q.offer(30);
System.out.println(q.peek());  // 10 (head)
System.out.println(q.poll());  // 10 (removes head)
System.out.println(q);         // [20, 30]
----

== Common Deque Operations
Two-ended operations (front = first/head, back = last/tail).

[cols="30,35,35", options="header"]
|===
| Operation | Front (head) | Back (tail)
| Insert     | `offerFirst(e)` / `addFirst(e)` | `offerLast(e)` / `addLast(e)`
| Remove     | `pollFirst()` / `removeFirst()` | `pollLast()` / `removeLast()`
| Peek       | `peekFirst()` / `getFirst()`    | `peekLast()` / `getLast()`
| Stack API  | `push(e)` (addFirst) | `pop()` (removeFirst) + `peek()`
|===

Example:
[source,java]
----
Deque<Integer> d = new ArrayDeque<>();
d.addFirst(2); d.addLast(3); d.addFirst(1); // [1,2,3]
System.out.println(d.peekFirst()); // 1
System.out.println(d.peekLast());  // 3
System.out.println(d.pollLast());  // 3 (now [1,2])
d.push(0);                         // stack push at front -> [0,1,2]
System.out.println(d.pop());       // 0
----

== Implementations

=== ArrayDeque
* **Resizable circular array**; excellent general-purpose `Queue`/`Deque`.
* ✅ `offerFirst/Last`, `pollFirst/Last`, `peekFirst/Last` are **O(1) amortized**.
* ✅ Fast stack ops: `push`/`pop` O(1).
* ❌ **No nulls** allowed.
* ❌ Not thread-safe.

=== LinkedList (as Deque)
* Doubly-linked list implementing `Deque`.
* ✅ O(1) insert/remove at both ends.
* ❌ Random access is O(n).
* Allows `null` elements (but avoid nulls in practice).

=== PriorityQueue
* Binary heap for **priority** order (default: **min-heap** on natural ordering).
* ✅ `offer` O(log n), `peek` O(1), `poll` O(log n).
* Order is by **priority**, **not FIFO**; iteration order is unspecified.
* Custom order via `new PriorityQueue<>(comparator)`.
* ❌ No nulls; not thread-safe; removing arbitrary element is O(n).

Min-heap vs max-heap:
[source,java]
----
// min-heap (default)
PriorityQueue<Integer> minpq = new PriorityQueue<>();

// max-heap
PriorityQueue<Integer> maxpq = new PriorityQueue<>(Comparator.reverseOrder());
----

== Complexity Snapshot
[cols="30,25,25,25", options="header"]
|===
| Operation | ArrayDeque | LinkedList (Deque) | PriorityQueue
| offer / add | O(1) amortized | O(1) | O(log n)
| poll / remove head | O(1) amortized | O(1) | O(log n)
| peek head | O(1) | O(1) | O(1)
| offerFirst/Last | O(1) amortized | O(1) | N/A
| pollFirst/Last | O(1) amortized | O(1) | N/A
| arbitrary remove | O(n) | O(n) | O(n)
|===

== Iteration Patterns
[source,java]
----
// Queue iteration (do NOT modify structure while foreach-ing)
Queue<Integer> q = new ArrayDeque<>(List.of(1,2,3));
for (int x : q) { System.out.print(x + " "); } // 1 2 3

// Safe removal with iterator
Iterator<Integer> it = q.iterator();
while (it.hasNext()) {
    if (it.next() % 2 == 0) it.remove();
}
System.out.println(q); // [1,3]
----

== Gotchas
* **Exceptions vs graceful methods**: prefer `offer/poll/peek` to avoid exceptions.
* **ArrayDeque**: no nulls; faster than `Stack` and `LinkedList` for stack use.
* **PriorityQueue**:
  - Heap only guarantees **head is min/max**; the rest are **not fully sorted**.
  - Iteration order is unspecified; to get sorted output, **poll repeatedly** or copy into list & sort.
  - Removing arbitrary element: O(n).
* **LinkedList** as Deque: good for frequent end insertions/removals; random access is slow.
* **Legacy `Stack`**: avoid; prefer `Deque` (`ArrayDeque`) for stack.

== DSA Patterns

=== BFS (Graph / Tree)
Use `Queue` (FIFO).
[source,java]
----
Queue<Integer> q = new ArrayDeque<>();
boolean[] vis = new boolean[n];
q.offer(src); vis[src] = true;
while (!q.isEmpty()) {
    int u = q.poll();
    for (int v : adj[u]) if (!vis[v]) { vis[v] = true; q.offer(v); }
}
----

=== Sliding Window (Fixed Size)
Maintain window with `Deque` or indices; for maximums use **monotonic deque** (next section).
[source,java]
----
int best = 0, sum = 0, k = 3;
for (int i = 0; i < n; i++) {
    sum += a[i];
    if (i >= k) sum -= a[i - k];
    if (i >= k - 1) best = Math.max(best, sum);
}
----

=== Monotonic Queue (Max in Window)
`Deque` stores indices in decreasing value order; front is current max.
[source,java]
----
int[] res = new int[n - k + 1];
Deque<Integer> dq = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    // remove indices out of window
    if (!dq.isEmpty() && dq.peekFirst() <= i - k) dq.pollFirst();
    // maintain decreasing values
    while (!dq.isEmpty() && a[dq.peekLast()] <= a[i]) dq.pollLast();
    dq.offerLast(i);
    if (i >= k - 1) res[i - k + 1] = a[dq.peekFirst()];
}
----

=== Kth Largest / Top-K Elements
Use a size-`k` **min-heap** (PriorityQueue). Keep only top k.
[source,java]
----
PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap
for (int x : arr) {
    pq.offer(x);
    if (pq.size() > k) pq.poll();
}
int kthLargest = pq.peek();
----

=== Merge K Sorted Lists / Streams
Min-heap by current head value.
[source,java]
----
record Node(int val, int i, int j) {}
PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(Node::val));
// push heads...
while (!pq.isEmpty()) {
    Node nd = pq.poll();
    // output nd.val, then push next from the same list (i,j+1) if exists
}
----

=== Task Scheduling by Priority
Max-heap with custom comparator (e.g., by frequency or deadline).
[source,java]
----
class Task { int pr; String name; }
PriorityQueue<Task> maxpq = new PriorityQueue<>((a,b) -> b.pr - a.pr);
// offer tasks, then poll in priority order
----

== API Quick Tables

=== Queue (key methods)
[cols="30,70", options="header"]
|===
| Method | Notes
| `offer(e)` | Insert; returns false if capacity-limited queue is full.
| `poll()` | Remove & return head; null if empty.
| `peek()` | Return head; null if empty.
| `add(e)` | Like offer but throws if cannot add.
| `remove()` | Like poll but throws if empty.
| `element()` | Like peek but throws if empty.
|===

=== Deque (additional)
[cols="30,70", options="header"]
|===
| Method | Notes
| `offerFirst/Last(e)` | Insert at front/back; false on failure (bounded).
| `pollFirst/Last()` | Remove & return front/back; null if empty.
| `peekFirst/Last()` | View front/back; null if empty.
| `addFirst/Last(e)` | Throwing insert variants.
| `removeFirst/Last()` | Throwing remove variants.
| `getFirst/Last()` | Throwing peek variants.
| `push(e)` / `pop()` | Stack-style aliases (front).
|===

== Choosing Between Implementations
* **General queue/deque** → `ArrayDeque` (fast, compact, no nulls).
* **Need list-like ops + deque** → `LinkedList` (O(1) at ends, O(n) random access).
* **Priority-based processing** → `PriorityQueue` (heap; O(log n) insert/remove-min).

== Notes on Concurrency (just pointers)
* For thread-safe queues: `ConcurrentLinkedQueue`, `ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`, etc.
* Most DSA practice uses non-blocking, single-threaded structures above.