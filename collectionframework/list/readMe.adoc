= List (ArrayList & LinkedList) – Quick Reference
:toc: macro
:toclevels: 2
:source-highlighter: highlightjs

[.lead]
Notes for the Java `List` interface: first the **common operations** that work for any List, then specifics for **ArrayList** and **LinkedList**. (`Vector`/`Stack` are legacy and only mentioned briefly.)

toc::[]

== Common List Operations
These apply to *all* `List` implementations (ArrayList, LinkedList, Vector, etc.) unless noted.

=== Creation
* `new ArrayList<>()`, `new LinkedList<>()` – empty list.
* `new ArrayList<>(collection)`, `new LinkedList<>(collection)` – copy from another collection.
* `Arrays.asList(…)` → **fixed-size** list; wrap with `new ArrayList<>(…)` if you need add/remove.
* `List.of(…)` → **immutable**; wrap with `new ArrayList<>(…)` for mutability.

=== Adding Elements
* `add(e)` – append at end *(amortized O(1) ArrayList; O(1) LinkedList tail)*.
* `add(index, e)` – insert at index *(O(n) traversal/shift)*.
* `addAll(coll)` / `addAll(index, coll)` – bulk add.

=== Access / Update
* `get(index)` – O(1) **ArrayList**, O(n) **LinkedList**.
* `set(index, e)` – O(1) **ArrayList**, O(n) **LinkedList**.

=== Removing Elements
* `remove(index)` – O(n) (shift/traverse).
* `remove(Object o)` – removes first occurrence; returns boolean.
* `removeAll(coll)` / `retainAll(coll)` – bulk remove/retain.
* `removeIf(predicate)` – conditional remove (Java 8+).
* `clear()` – remove all.

=== Searching
* `contains(e)` – O(n)
* `indexOf(e)` / `lastIndexOf(e)`
* `containsAll(coll)`

=== Size & Capacity
* `size()`, `isEmpty()`
* **ArrayList only:** `ensureCapacity(n)`, `trimToSize()` (capacity tuning for dynamic array)

=== Conversion
* `toArray()` → `Object[]`
* `toArray(T[])` → typed array, e.g. `toArray(new Integer[0])`

=== Iteration
* Index loop: `for (int i=0; i<list.size(); i++)`
* For-each: `for (T x : list)`
* `Iterator<T>` / `iterator.remove()` (safe removal during iteration)
* `ListIterator<T>` (bi-directional, `set`, `add`, `previous`)
* `forEach(consumer)` (Java 8+)

=== Sorting & Other Utilities (Collections)
* `Collections.sort(list)` / `Collections.sort(list, comparator)`
* `Collections.shuffle(list)`
* `Collections.swap(list, i, j)`
* `Collections.fill(list, val)`
* `Collections.copy(dest, src)` *(dest.size() ≥ src.size())*
* `Collections.min(list)` / `Collections.max(list)`
* `Collections.frequency(list, e)`
* `Collections.binarySearch(sortedList, key)` *(must be sorted with same comparator)*

=== Streams & Bulk Ops (Java 8+)
* Transform: `list.replaceAll(fn)`
* Filter: `list.removeIf(pred)`
* Streams:
+
[source,java]
----
List<Integer> squared = list.stream().map(x -> x*x).toList();
List<Integer> evens = list.stream().filter(x -> x%2==0).toList();
list.forEach(System.out::println);
----

=== SubList (Backed View)
* `subList(from, to)` returns a **view** over `[from, to)`.
* Mutations on the view reflect in the parent.
* Avoid structural modifications on parent while view exists (can cause `ConcurrentModificationException`).

=== Equality & Hashing
* `equals()` compares element-by-element **and order**.
* `hashCode()` consistent with `equals()`.

=== Complexity Snapshot
[cols="30,35,35", options="header"]
|===
| Operation | ArrayList | LinkedList
| Access (get/set) | O(1) | O(n)
| Add at end | Amortized O(1) | O(1) (tail)
| Insert/remove at index | O(n) (shift) | O(n) (traverse), O(1) once node located
| Search by value | O(n) | O(n)
| Sort | O(n log n) | O(n log n)
|===

=== Gotchas
* `remove(int)` vs `remove(Object)` – be explicit to avoid ambiguity with boxed integers.
* `Arrays.asList` is fixed-size; wrap in `new ArrayList<>(…)` to add/remove.
* `subList` is *backed*; don’t structurally modify parent while using it.
* Prefer declaring as interface: 
+
[source,java]
----
List<Integer> list = new ArrayList<>();
----

== ArrayList Specific Notes
* Backed by a **dynamically resizing array** (growth typically ~1.5×).
* **Fast random access**: `get/set` are O(1).
* **Capacity tuning** (unique to ArrayList):
+
[source,java]
----
ArrayList<Integer> a = new ArrayList<>();
a.ensureCapacity(1_000);
... // bulk add
a.trimToSize(); // shrink backing array to current size
----
* Insert/remove in middle causes **shifts** (O(n)); prefer appending or using algorithms that minimize mid-list insertions.

== LinkedList Specific Notes
* **Doubly-linked list** implementation of `List` (also implements `Deque`).
* **O(1)** insertion/removal at ends (once position known).
* **O(n)** random access (`get(i)`, `set(i)` traverse from nearest end).
* Deque operations you get on `LinkedList` (not on `ArrayList`):
+
[source,java]
----
// Queue-like
LinkedList<Integer> q = new LinkedList<>();
q.addLast(10);  // offer/add at tail
q.addLast(20);
System.out.println(q.removeFirst()); // poll/remove head

// Stack-like
q.push(99);               // same as addFirst
System.out.println(q.pop()); // removeFirst
System.out.println(q.peekFirst()); // view head
System.out.println(q.peekLast());  // view tail
----

== Legacy Implementations
* `Vector` – synchronized dynamic array; largely superseded by `ArrayList`.
* `Stack` – legacy LIFO (extends Vector). Prefer `Deque`/`ArrayDeque` instead.