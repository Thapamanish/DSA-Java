= Heap Sort — Story, Intuition, and Notes

== 🪢 Story / Analogy
Imagine a knockout tournament where the strongest player always rises to the top.
We first organize players into a *max-heap* (a complete binary tree where each parent ≥ its children).
The champion (largest value) is at the root.
Move the champion to the end (final position), then re-organize the remaining players (heapify) to find the next champion.
Repeat until everyone is placed — that’s Heap Sort.

== 🔍 Algorithm (Ascending)
. **Build a Max-Heap** from the array (in-place):
.. Start from the last non-leaf node (`n/2 - 1`) down to `0`, and `heapify` each node.
. **Extract max repeatedly**:
.. Swap root (index `0`) with the last element of the heap section.
.. Reduce heap size by 1.
.. `heapify(0)` to restore the max-heap property.
. Continue until the heap size becomes 1.

== ⏱️ Complexity
* *Time*:
** Build heap: `O(N)`
** Each extract-max + heapify: `O(log N)` repeated `N` times → `O(N log N)` total
* *Space*: `O(1)` (in-place)
* *Stability*: **Not stable** (equal elements may change relative order)

== ✅ When to Use
* In-place `O(N log N)` required (no extra arrays like Merge Sort).
* Predictable performance; no worst-case `O(N^2)` like Quick Sort.

== 🧠 Correctness Sketch
* Building a max-heap ensures the largest element is at the root.
* After swapping root with the end, the largest is fixed at its correct final position.
* Recursively restoring the heap on the reduced range ensures the next largest rises to the root.
* By induction, the whole array becomes sorted.

== 🧪 Dry Run (Brief)
Input: `[4, 10, 3, 5, 1]`

. Build max-heap → `[10, 5, 3, 4, 1]`
. Swap 10 with last → `[1, 5, 3, 4, 10]`, heapify (size=4) → `[5, 4, 3, 1, 10]`
. Swap 5 with last of heap → `[1, 4, 3, 5, 10]`, heapify (size=3) → `[4, 1, 3, 5, 10]`
. Swap 4 → `[3, 1, 4, 5, 10]`, heapify (size=2) → `[3, 1, 4, 5, 10]`
. Swap 3 → `[1, 3, 4, 5, 10]` → Sorted ✅