= Heap Sort â€” Story, Intuition, and Notes

== ğŸª¢ Story / Analogy
Imagine a knockout tournament where the strongest player always rises to the top.
We first organize players into a *max-heap* (a complete binary tree where each parent â‰¥ its children).
The champion (largest value) is at the root.
Move the champion to the end (final position), then re-organize the remaining players (heapify) to find the next champion.
Repeat until everyone is placed â€” thatâ€™s Heap Sort.

== ğŸ” Algorithm (Ascending)
. **Build a Max-Heap** from the array (in-place):
.. Start from the last non-leaf node (`n/2 - 1`) down to `0`, and `heapify` each node.
. **Extract max repeatedly**:
.. Swap root (index `0`) with the last element of the heap section.
.. Reduce heap size by 1.
.. `heapify(0)` to restore the max-heap property.
. Continue until the heap size becomes 1.

== â±ï¸ Complexity
* *Time*:
** Build heap: `O(N)`
** Each extract-max + heapify: `O(log N)` repeated `N` times â†’ `O(N log N)` total
* *Space*: `O(1)` (in-place)
* *Stability*: **Not stable** (equal elements may change relative order)

== âœ… When to Use
* In-place `O(N log N)` required (no extra arrays like Merge Sort).
* Predictable performance; no worst-case `O(N^2)` like Quick Sort.

== ğŸ§  Correctness Sketch
* Building a max-heap ensures the largest element is at the root.
* After swapping root with the end, the largest is fixed at its correct final position.
* Recursively restoring the heap on the reduced range ensures the next largest rises to the root.
* By induction, the whole array becomes sorted.

== ğŸ§ª Dry Run (Brief)
Input: `[4, 10, 3, 5, 1]`

. Build max-heap â†’ `[10, 5, 3, 4, 1]`
. Swap 10 with last â†’ `[1, 5, 3, 4, 10]`, heapify (size=4) â†’ `[5, 4, 3, 1, 10]`
. Swap 5 with last of heap â†’ `[1, 4, 3, 5, 10]`, heapify (size=3) â†’ `[4, 1, 3, 5, 10]`
. Swap 4 â†’ `[3, 1, 4, 5, 10]`, heapify (size=2) â†’ `[3, 1, 4, 5, 10]`
. Swap 3 â†’ `[1, 3, 4, 5, 10]` â†’ Sorted âœ…