= Bubble Sort â€” Story, Intuition, and Notes

== ğŸª¢ Story / Analogy
Imagine bubbles rising in water. The *largest bubble* rises fastest to the top.  
In Bubble Sort, in each pass, the *largest remaining element* rises (or "bubbles up") to its correct position at the end.

== ğŸ” Algorithm (Ascending)
Repeat for `i = 0` to `n-2`:
. Compare adjacent pairs `(arr[j], arr[j+1])`.
. If `arr[j] > arr[j+1]`, swap them.
. After each full pass, the largest element is at index `n - i - 1`.

Optimization:  
If no swaps occur during a pass, the array is already sorted â†’ break early.

== â±ï¸ Complexity
* *Time*: 
** Worst & Average: `O(N^2)`
** Best: `O(N)` (when input already sorted, thanks to the swapped flag)
* *Space*: `O(1)` (in-place)
* *Stability*: *Stable* (equal elements do not change relative order)

== âœ… When to Use (and When Not)
* Great for teaching and learning sorting concepts.
* Not used in practice for large inputs (slow).
* Works well if the array is *almost sorted* (early exit makes it fast).

== ğŸ§  Correctness Sketch
* Each pass ensures the next-largest element is placed in its correct position at the end.
* By induction, after `i` passes, the last `i` elements are sorted and in final position.

== ğŸ§ª Dry Run
Array: `[5, 1, 4, 2, 8]`

* Pass 1:
** Compare 5,1 â†’ swap â†’ `[1, 5, 4, 2, 8]`
** Compare 5,4 â†’ swap â†’ `[1, 4, 5, 2, 8]`
** Compare 5,2 â†’ swap â†’ `[1, 4, 2, 5, 8]`
** Compare 5,8 â†’ no swap â†’ `[1, 4, 2, 5, 8]`
Result: largest element 8 at end.

* Pass 2:
** Compare 1,4 â†’ no swap
** Compare 4,2 â†’ swap â†’ `[1, 2, 4, 5, 8]`
** Compare 4,5 â†’ no swap
Result: 5 in place.

* Pass 3:
** Compare 1,2 â†’ no swap
** Compare 2,4 â†’ no swap
Result: already sorted, loop ends.

Final: `[1, 2, 4, 5, 8]`