= Insertion Sort

== Idea

Insertion Sort mimics the way many people sort a hand of playing cards.

* The array is conceptually divided into a sorted and an unsorted part.
* Elements from the unsorted part are picked one by one and placed at their correct position in the sorted part.
* This process is repeated until the entire array is sorted.

== Pseudocode

[source,pseudocode]
----
for i = 1 to n-1:
    key = arr[i]
    j = i-1
    // Shift elements of the sorted part that are greater than the key
    // one position to the right to make space.
    while j >= 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j--
    arr[j+1] = key
----

== Characteristics

* *Worst / Average Time Complexity:* `O(n^2^)`
* *Best Case Time Complexity (already sorted):* `O(n)`
* *Space Complexity:* `O(1)` (in-place)
* *Stability:* Stable (does not change the relative order of equal elements)

[TIP]
====
Due to its efficiency with small or nearly-sorted data, Insertion Sort is often used as a component in more advanced hybrid algorithms like TimSort, which is the default sorting algorithm in Java and Python.
====

= Insertion Sort: The Card Sorting Analogy üÉè

The best analogy for Insertion Sort is how most people naturally sort a hand of playing cards.

Imagine you're dealt cards one by one. You pick up the first card and hold it in your left hand. By definition, this single card is a "sorted" hand.

Now, the dealer gives you a second card. You pick it up with your right hand and compare it to the card in your left. You slide it either in front of or behind that first card to keep them in order. You now have a sorted hand of two cards.

Here comes the third card. You pick it up and compare it to the cards in your sorted hand, starting from the *rightmost* one.

* If the new card is larger than the card you're looking at, you've already found its spot.
* If it's smaller, you mentally *shift* that larger card to the right to make space and then compare your new card to the next one over.

You continue this "compare and shift" process until you find the correct empty slot to *insert* your new card.

== How it Maps to the Algorithm

Let's see this with the array `[5, 2, 4, 1]`. The `|` character separates the "sorted hand" (left) from the "unsorted pile" (right).

. *Initial State*: Your hand is `[5]`. The rest is the pile.
+
....
[ 5 | 2, 4, 1 ]
....

. *Pick `2`*:
.. Compare `2` with `5`. `2` is smaller.
.. Shift `5` to the right to make a gap: `[ _, 5 ]`
.. *Insert* `2` into the gap.
+
....
Result: [ 2, 5 | 4, 1 ]
....

. *Pick `4`*:
.. Compare `4` with `5`. `4` is smaller.
.. Shift `5` right: `[ 2, _, 5 ]`
.. Compare `4` with `2`. `4` is larger, so we've found the spot.
.. *Insert* `4` into the gap.
+
....
Result: [ 2, 4, 5 | 1 ]
....

. *Pick `1`*:
.. Compare `1` with `5`. `1` is smaller. Shift `5`.
.. Compare `1` with `4`. `1` is smaller. Shift `4`.
.. Compare `1` with `2`. `1` is smaller. Shift `2`.
.. We're at the beginning. *Insert* `1`.
+
....
Final Result: [ 1, 2, 4, 5 ]
....

The array is now sorted. You built up the sorted portion of the array by taking one element at a time and *inserting* it into its correct position.

---
== Why It‚Äôs Useful

* If the cards are almost sorted already, you don‚Äôt shift much, making it very fast (`O(n)`).
* If the cards are in reverse order, you shift a lot for every card, making it slower (`O(n^2^)`)
* This is why Insertion Sort is excellent for small or nearly sorted arrays.