= Insertion Sort — Story, Intuition, and Notes

== 🪢 Story / Analogy
Imagine you’re sorting a hand of playing cards 🃏.
You pick up one card at a time and place it into the correct position among the cards you’ve already arranged.
Each new card gets “inserted” into its right spot in the sorted portion.

That’s exactly how Insertion Sort works.

== 🔍 Algorithm (Ascending)
For `i = 1` to `n-1`:
. Let `key = arr[i]`.
. Compare `key` with elements in the sorted subarray `[0..i-1]`.
. Shift all larger elements one step to the right.
. Insert `key` in its correct place.

== ⏱️ Complexity
* *Time*:  
** Worst & Average: `O(N^2)` (each insertion may shift nearly N elements).  
** Best: `O(N)` (when the array is already sorted, only comparisons happen).  
* *Space*: `O(1)` (in-place).  
* *Stability*: *Stable* (equal elements preserve their relative order).

== ✅ When to Use (and When Not)
* Excellent for *small arrays* or arrays that are *almost sorted*.  
* Used in practice for *online algorithms* (when numbers arrive one by one and need to be kept sorted).  
* Not efficient for large, random arrays.

== 🧠 Correctness Sketch
* At the start of iteration `i`, the subarray `[0..i-1]` is sorted.
* We insert `arr[i]` into the correct position inside `[0..i-1]`.
* By induction, after `i` steps, `[0..i]` is sorted.
* After the final step, the whole array is sorted.

== 🧪 Dry Run
Array: `[5, 3, 4, 1]`

* `i=1`: key=3  
  Compare with 5 → shift → `[5,5,4,1]`  
  Insert 3 → `[3,5,4,1]`

* `i=2`: key=4  
  Compare with 5 → shift → `[3,5,5,1]`  
  Insert 4 → `[3,4,5,1]`

* `i=3`: key=1  
  Compare with 5 → shift → `[3,4,5,5]`  
  Compare with 4 → shift → `[3,4,4,5]`  
  Compare with 3 → shift → `[3,3,4,5]`  
  Insert 1 → `[1,3,4,5]`

Final result: `[1, 3, 4, 5]`