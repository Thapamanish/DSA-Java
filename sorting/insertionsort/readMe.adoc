= Insertion Sort â€” Story, Intuition, and Notes

== ğŸª¢ Story / Analogy
Imagine youâ€™re sorting a hand of playing cards ğŸƒ.
You pick up one card at a time and place it into the correct position among the cards youâ€™ve already arranged.
Each new card gets â€œinsertedâ€ into its right spot in the sorted portion.

Thatâ€™s exactly how Insertion Sort works.

== ğŸ” Algorithm (Ascending)
For `i = 1` to `n-1`:
. Let `key = arr[i]`.
. Compare `key` with elements in the sorted subarray `[0..i-1]`.
. Shift all larger elements one step to the right.
. Insert `key` in its correct place.

== â±ï¸ Complexity
* *Time*:  
** Worst & Average: `O(N^2)` (each insertion may shift nearly N elements).  
** Best: `O(N)` (when the array is already sorted, only comparisons happen).  
* *Space*: `O(1)` (in-place).  
* *Stability*: *Stable* (equal elements preserve their relative order).

== âœ… When to Use (and When Not)
* Excellent for *small arrays* or arrays that are *almost sorted*.  
* Used in practice for *online algorithms* (when numbers arrive one by one and need to be kept sorted).  
* Not efficient for large, random arrays.

== ğŸ§  Correctness Sketch
* At the start of iteration `i`, the subarray `[0..i-1]` is sorted.
* We insert `arr[i]` into the correct position inside `[0..i-1]`.
* By induction, after `i` steps, `[0..i]` is sorted.
* After the final step, the whole array is sorted.

== ğŸ§ª Dry Run
Array: `[5, 3, 4, 1]`

* `i=1`: key=3  
  Compare with 5 â†’ shift â†’ `[5,5,4,1]`  
  Insert 3 â†’ `[3,5,4,1]`

* `i=2`: key=4  
  Compare with 5 â†’ shift â†’ `[3,5,5,1]`  
  Insert 4 â†’ `[3,4,5,1]`

* `i=3`: key=1  
  Compare with 5 â†’ shift â†’ `[3,4,5,5]`  
  Compare with 4 â†’ shift â†’ `[3,4,4,5]`  
  Compare with 3 â†’ shift â†’ `[3,3,4,5]`  
  Insert 1 â†’ `[1,3,4,5]`

Final result: `[1, 3, 4, 5]`