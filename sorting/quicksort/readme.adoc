= Quick Sort ‚Äî Story, Intuition, and Notes

== ü™¢ Story / Analogy
Imagine a teacher lining up students by height using a "divide & conquer" approach:

1. The teacher picks one student as the *pivot*.
2. Students shorter or equal to the pivot move to the left, taller students move to the right.
3. Now the pivot is in its *final correct position*.
4. Deputies repeat the process on the left group and the right group until every group has only one student.

This is Quick Sort in action.

== üîç Algorithm (Lomuto Partition, Ascending)
. Choose the last element as pivot.
. Partition the array so that:
   * Elements ‚â§ pivot are on the left.
   * Elements > pivot are on the right.
. Place pivot at the correct position.
. Recursively apply Quick Sort to the left and right parts.

== ‚è±Ô∏è Complexity
* *Best / Average*: O(N log N)  
* *Worst*: O(N^2) (if pivot is always smallest/largest, e.g. already sorted array with last-element pivot).  
* *Space*: O(log N) recursion stack.  
* *Stability*: Not stable (equal elements may change relative order).

== ‚úÖ Tips
* Randomizing pivot or using "median-of-three" reduces worst-case chances.  
* Generally faster than Merge Sort in practice (better cache performance, no extra O(N) memory).  

== üß† Correctness
* Pivot ends up in its correct position after partition.  
* Recursively, both left and right subarrays become sorted.  
* By induction, the whole array is sorted.  

== üß™ Dry Run
Array: [10, 7, 8, 9, 1, 5]

* Pivot = 5 (last element).  
* Partition: [1, 5, 8, 9, 10, 7], pivot placed at index 1.  
* Left side: [1] ‚Üí already sorted.  
* Right side: [8, 9, 10, 7].  
  - Pivot = 7 ‚Üí after partition [7, 9, 10, 8].  
  - Left = [] (empty).  
  - Right = [9, 10, 8].  
    * Pivot = 8 ‚Üí [8, 10, 9].  
    * Recursively sort [10, 9] ‚Üí [9, 10].  
Final result: [1, 5, 7, 8, 9, 10].