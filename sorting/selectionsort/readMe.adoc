= Selection Sort — Story, Intuition, and Notes

== 🪢 Story / Analogy
Imagine you’re arranging books from *shortest to tallest* on a shelf.
You start at the far left slot:

1. Look through *all* the remaining books to find the *shortest* one.
2. Put that shortest book in the current slot.
3. Move to the next slot and repeat.

That’s *Selection Sort*: at each step, *select* the smallest from the unsorted part and place it at the current position.

== 🔍 Algorithm (Ascending)
For `i = 0` to `n-2`:
. Find `minIdx` = index of the minimum in the range `[i..n-1]`.
. Swap `arr[i]` and `arr[minIdx]`.

After `i` moves across the array, everything to the left of `i` is sorted.

== ⏱️ Complexity
* *Time*: `O(N^2)` in best/avg/worst (because we scan the unsorted part each time).
* *Space*: `O(1)` in-place.
* *Stability*: *Not stable* (equal elements may swap and change their relative order).

NOTE: Not stable because the algorithm swaps the found minimum with `arr[i]` directly, which can jump equal elements over each other.

== ✅ When to Use (and When Not)
* Simple to implement and *works in-place* without extra memory.
* Good for *very small arrays* or when *memory is extremely tight*.
* Not great for large arrays because it’s always `O(N^2)`.

== 🧠 Correctness Sketch
* After iteration `i`, the smallest element of the suffix `[i..n-1]` is placed at index `i`.
* By induction, the prefix `[0..i]` is sorted and contains the `i+1` smallest elements.
* Therefore the whole array ends sorted.

== 🔧 Tip: Stable Variant?
Selection sort is typically *not stable*.  
You can make a stable variant by *extracting* the minimum and *shifting* elements right by one to insert it at `i` (instead of swapping).  
But that increases the number of moves, so it’s rarely used.

== 🧪 Dry Run
Array: `[4, 2, 5, 2, 3]`

* `i=0`: min in `[4,2,5,2,3]` is `2` at index 1 → swap with index 0  
  → `[2, 4, 5, 2, 3]`
* `i=1`: min in `[4,5,2,3]` is `2` at index 3 → swap with index 1  
  → `[2, 2, 5, 4, 3]`
* `i=2`: min in `[5,4,3]` is `3` at index 4 → swap with index 2  
  → `[2, 2, 3, 4, 5]`
* `i=3`: min in `[4,5]` is `4` → swap with itself  
  → `[2, 2, 3, 4, 5]`
* Done ✅