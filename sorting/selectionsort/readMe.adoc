= Selection Sort

== Idea
* Divide the array into two parts: a sorted subarray on the left and an unsorted subarray on the right.
* Repeatedly find the minimum element from the unsorted part and move it to the end of the sorted part.
* After `i` passes, the first `i` elements are sorted and in their final positions.

[NOTE]
====
Unlike Bubble Sort, which performs many swaps, Selection Sort is optimal in terms of swaps, performing at most `n-1` of them.
====

== Pseudocode
[source,pseudocode]
----
for i = 0 to n-2:
    minIndex = i
    for j = i+1 to n-1:
        if arr[j] < arr[minIndex]:
            minIndex = j
    swap(arr[i], arr[minIndex])
----

== Complexity
* *Time:* `O(n^2^)` (The number of comparisons is fixed, regardless of the initial order).
* *Space:* `O(1)` (in-place).
* *Stability:* Unstable (it can change the relative order of equal elements).